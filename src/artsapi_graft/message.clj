(ns artsapi-graft.message
  (:require [artsapi-graft.prefixers :refer [email-uri]]
            [clojure-mail.parser :refer :all :as parse]
            [clojure-mail.message :as msg :refer [message-body
                                                  safe-get]])
  (:import [javax.mail.internet
            MimeMessage
            MimeMultipart
            InternetAddress
            MimeUtility]
           [javax.mail Message Message$RecipientType]))

;; To do: clean up the way that nils are dealt with in this namespace.
;; At present the risk of passing nils forward in the simple branching
;; logic cases is too great - these could be simpler.

(defn get-header
  "Returns the header corresponding to the string passed in, if it exists.
   This will be returned as a string or vector of strings."
  [msg header]
  (let [header-field (.getHeader msg header)]
    (when (not= nil header-field)
      (if (> (count header-field) 1)
        (lazy-seq header-field)
        (str (get header-field 0))))))

(defn get-to-from-header
  "Primarily for error recovery in cases of malformed fields.
   Extracts only the first email address it can and returns
   that as the correct javamail class."
  [msg]
  (conj '() (javax.mail.internet.InternetAddress. (re-find #"<\S+>" (get-header msg "to")))))

(defn get-cc-from-header
  "Primarily for error recovery in cases of malformed fields.
   Extracts only the first email address it can and returns
   that as the correct javamail class."
  [msg]
  (conj '() (javax.mail.internet.InternetAddress. (re-find #"^<\S+" (get-header msg "cc")))))


(defn get-subject
  [msg]
  (.getSubject msg))

(defn get-sender
  "Returns a InternetAddress object from the sender's metadata."
  [msg]
  (let [sender-email (try
                       (.getFrom msg)
                       (catch javax.mail.internet.AddressException e
                         '("nil@example.com")))]
    (get sender-email 0)))

(defn get-to
  "Returns a InternetAddress object of all recipients' addresses, or a set of them."
  [msg]
  (into #{} (try
              (.getRecipients msg Message$RecipientType/TO)
              (catch javax.mail.internet.AddressException e
                (get-to-from-header msg)))))

(defn get-sent-date
  "Returns a clojure date time instance corresponding to the send date."
  [msg]
  (.getSentDate msg))

(defn sent-date->str
  "Returns a string of the date and time an email was sent."
  [msg]
  (str (get-sent-date msg)))

(defn get-received-date
  "Returns a clojure date time instance corresponding to the received date."
  [msg]
  (.getReceivedDate msg))

(defn received-date->str
  "Returns a string of the date and time an email was received."
  [msg]
  (str (get-received-date msg)))

(defn address->str
  "Returns a string generated by calling getAddress on an InternetAddress object."
  [address]
  (when-not (= nil address)
    (.getAddress address)))

(defn get-personal
  "Returns a string generated by calling getPersonal on an InternetAddress object."
  [address]
  (if-not (nil? address)
    (.getPersonal address)
    "nil"))

(defn get-domain
  "Returns a fully qualified domain name extracted from an email address."
  [address]
  (if (nil? address)
    "nil.example.com"
    (let [addr (address->str address)]
      (try
        (subs (re-find #"@.+" addr) 1)
        (catch java.lang.NullPointerException e
          "nil.example.com")))))

(defn get-cc
  "Returns an InternetAddress object of CC recipients, or a set containing them."
  [msg]
  (into #{} (try
              (.getRecipients msg Message$RecipientType/CC)
              (catch javax.mail.internet.AddressException e
                (get-cc-from-header msg)))))

(defn get-content
  "Get message contents"
  [msg]
  (let [content-hash (msg/safe-get (msg/message-body msg))]
    (try
      (:body (first (filter #(re-find #"text/plain" (:content-type %)) content-hash)))
      (catch Exception e
          "nil"))))

;; Ultimately, we want to wrap this in a try/catch block and cause all
;; the methods above to raise errors if they cannot resolve. For core
;; fields (i.e. the sender), we would then want to scrub the whole
;; message and not generate any quads

(defn ->msg
  "Return a map of strings representing the message."
  [msg]
  (let [sender (get-sender msg)
        from-str (address->str (get-sender msg))
        date (sent-date->str msg)
        subj (get-subject msg)
        email-resource-uri (email-uri from-str date subj)]
    {:from (or from-str "nil")
     :from-personal (get-personal sender)
     :from-domain (get-domain sender)
     :sent-date date
     :to (map #(-> {:email-uri email-resource-uri
                    :personal (get-personal %)
                    :email (address->str %)
                    :domain (get-domain %)})
              (get-to msg))
     :subject subj
     :cc (map #(-> {:email-uri email-resource-uri
                    :personal (get-personal %)
                    :email (address->str %)
                    :domain (get-domain %)})
              (get-cc msg))
     :content (get-content msg)}))

